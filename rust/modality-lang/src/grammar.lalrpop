use crate::ast::{Model, Part, Transition, Property, PropertySign, PropertySource, Formula, FormulaExpr, PartState, TopLevelItem, Action, ActionCall, Test, TestStatement, Contract, ContractCommit, CommitStatement, ModelBodyItem};

grammar;

pub TopLevel: Vec<Model> = {
    <items:TopLevelItem*> => {
        let mut models = Vec::new();
        for item in items {
            if let TopLevelItem::Model(model) = item {
                models.push(model);
            }
        }
        models
    }
};

TopLevelItem: TopLevelItem = {
    <model:Model> => TopLevelItem::Model(model),
    <formula:Formula> => TopLevelItem::Formula(formula),
    <action:Action> => TopLevelItem::Action(action),
    <test:Test> => TopLevelItem::Test(test),
    <contract:ContractDecl> => TopLevelItem::Contract(contract)
};

pub Model: Model = {
    <model:ModelDecl> => model
};

ModelDecl: Model = {
    // Named model: model name { ... }
    "model" <name:Ident> "{" <items:ModelBodyItem*> "}" => {
        let mut model = Model::new(name);
        for item in items {
            match item {
                ModelBodyItem::Initial(state) => model.set_initial(state),
                ModelBodyItem::Transition(t) => model.add_transition(t),
                ModelBodyItem::Part(p) => model.add_part(p),
            }
        }
        model
    },
    // Default export: export default model { ... }
    "export" "default" "model" "{" <items:ModelBodyItem*> "}" => {
        let mut model = Model::new("default".to_string());
        for item in items {
            match item {
                ModelBodyItem::Initial(state) => model.set_initial(state),
                ModelBodyItem::Transition(t) => model.add_transition(t),
                ModelBodyItem::Part(p) => model.add_part(p),
            }
        }
        model
    }
};

ModelBodyItem: ModelBodyItem = {
    "initial" <state:Ident> => ModelBodyItem::Initial(state),
    <t:SimpleTransition> => ModelBodyItem::Transition(t),
    <p:Part> => ModelBodyItem::Part(p),
};

// Simple transition syntax: from -> to [+prop] (new) or from --> to : +prop (legacy)
SimpleTransition: Transition = {
    // New syntax: ->
    <from:Ident> "->" <to:Ident> => {
        Transition::new(from, to)
    },
    <from:Ident> "->" <to:Ident> "[" <properties:PropertyList> "]" => {
        let mut transition = Transition::new(from, to);
        for property in properties {
            transition.add_property(property);
        }
        transition
    },
    // Legacy syntax: -->
    <from:Ident> "-->" <to:Ident> => {
        Transition::new(from, to)
    },
    <from:Ident> "-->" <to:Ident> ":" <properties:PropertyList> => {
        let mut transition = Transition::new(from, to);
        for property in properties {
            transition.add_property(property);
        }
        transition
    }
};

Part: Part = {
    "part" <name:Ident> "{" <transitions:SimpleTransition*> "}" => {
        let mut part = Part::new(name);
        for transition in transitions {
            part.add_transition(transition);
        }
        part
    }
};

PropertyList: Vec<Property> = {
    <property:Property> => vec![property],
    <properties:PropertyList> <property:Property> => {
        let mut props = properties;
        props.push(property);
        props
    }
};

Property: Property = {
    "+" <name:Ident> => Property::new(PropertySign::Plus, name),
    "-" <name:Ident> => Property::new(PropertySign::Minus, name),
    // Predicate function call: +name("arg") or +name(arg)
    "+" <name:Ident> "(" <arg:PredicateArg> ")" => {
        Property::new_predicate_from_call(name, arg)
    },
    // Negated predicate: -name("arg")
    "-" <name:Ident> "(" <arg:PredicateArg> ")" => {
        Property::new_predicate_from_call_negated(name, arg)
    },
    // Special case: +signed_by(X) - keyword used as predicate name
    "+" "signed_by" "(" <arg:PredicateArg> ")" => {
        Property::new_predicate_from_call("signed_by".to_string(), arg)
    },
    // Special case: -signed_by(X)
    "-" "signed_by" "(" <arg:PredicateArg> ")" => {
        Property::new_predicate_from_call_negated("signed_by".to_string(), arg)
    }
};

// Predicate arguments can be strings, identifiers, or paths
PredicateArg: String = {
    <s:StringLiteral> => s,
    <i:Ident> => i,
    <p:PathLiteral> => p
};

// Path literal like /users/alice.id
PathLiteral: String = {
    r#"/[a-zA-Z0-9_./]+"# => <>.to_string()
};

// Action parsing
pub Action: Action = {
    <action:ActionDecl> => action
};

ActionDecl: Action = {
    "action" <name:Ident> "{" <properties:PropertyList> "}" => {
        Action::new(name, properties)
    }
};

// Action call parsing
pub ActionCall: ActionCall = {
    <call:ActionCallExpr> => call
};

ActionCallExpr: ActionCall = {
    "action" "(" <arg:StringLiteral> ")" => ActionCall::new(arg)
};

// Test parsing
pub Test: Test = {
    <test:TestDecl> => test
};

TestDecl: Test = {
    "test" "{" <statements:TestStatementList?> "}" => {
        Test::with_statements(None, statements.unwrap_or_default())
    },
    "test" <name:Ident> "{" <statements:TestStatementList?> "}" => {
        Test::with_statements(Some(name), statements.unwrap_or_default())
    }
};

TestStatementList: Vec<TestStatement> = {
    <stmt:TestStatement> => vec![stmt],
    <stmts:TestStatementList> <stmt:TestStatement> => {
        let mut list = stmts;
        list.push(stmt);
        list
    }
};

TestStatement: TestStatement = {
    // Assignment: m = clone(ModelName)
    <var:Ident> "=" "clone" "(" <model:Ident> ")" => {
        TestStatement::Assignment(var, format!("clone({})", model))
    },
    // Method call: m.commit(ActionName)
    <var:Ident> "." "commit" "(" <action:Ident> ")" => {
        TestStatement::Commit(format!("{}.commit({})", var, action))
    },
    // Method call with action literal: m.commit(action("+hello"))
    <var:Ident> "." "commit" "(" "action" "(" <arg:StringLiteral> ")" ")" => {
        TestStatement::ActionCall(format!("{}.commit(action({}))", var, arg))
    },
    // Assertion: assert m.satisfies(FormulaName)
    "assert" <var:Ident> "." "satisfies" "(" <formula:Ident> ")" => {
        TestStatement::Assignment(format!("assert_{}", var), format!("satisfies({})", formula))
    }
};

StringLiteral: String = {
    r#""[^"]*""# => {
        let s = <>.to_string();
        s[1..s.len()-1].to_string() // Remove quotes
    }
};

// Formula parsing
pub Formula: Formula = {
    <formula:FormulaDecl> => formula
};

FormulaDecl: Formula = {
    "formula" <name:Ident> "{" <expr:FormulaExpr> "}" => {
        Formula::new(name, expr)
    }
};

FormulaExpr: FormulaExpr = {
    <expr:FormulaOrExpr> => expr
};

FormulaOrExpr: FormulaExpr = {
    <expr:FormulaImpliesExpr> => expr,
    <expr:FormulaOrExpr> "or" <expr2:FormulaImpliesExpr> => {
        FormulaExpr::Or(Box::new(expr), Box::new(expr2))
    },
    <expr:FormulaOrExpr> "|" <expr2:FormulaImpliesExpr> => {
        FormulaExpr::Or(Box::new(expr), Box::new(expr2))
    }
};

FormulaImpliesExpr: FormulaExpr = {
    <expr:FormulaAndExpr> => expr,
    <expr:FormulaAndExpr> "->" <expr2:FormulaImpliesExpr> => {
        FormulaExpr::Implies(Box::new(expr), Box::new(expr2))
    },
    <expr:FormulaAndExpr> "implies" <expr2:FormulaImpliesExpr> => {
        FormulaExpr::Implies(Box::new(expr), Box::new(expr2))
    }
};

FormulaAndExpr: FormulaExpr = {
    <expr:FormulaUntilExpr> => expr,
    <expr:FormulaAndExpr> "and" <expr2:FormulaUntilExpr> => {
        FormulaExpr::And(Box::new(expr), Box::new(expr2))
    },
    <expr:FormulaAndExpr> "&" <expr2:FormulaUntilExpr> => {
        FormulaExpr::And(Box::new(expr), Box::new(expr2))
    }
};

FormulaUntilExpr: FormulaExpr = {
    <expr:FormulaAtom> => expr,
    <expr:FormulaAtom> "until" <expr2:FormulaUntilExpr> => {
        FormulaExpr::Until(Box::new(expr), Box::new(expr2))
    }
};

FormulaAtom: FormulaExpr = {
    "true" => FormulaExpr::True,
    "false" => FormulaExpr::False,
    // State proposition (node name)
    <name:Ident> => FormulaExpr::Prop(name),
    // Negation
    "not" <expr:FormulaAtom> => {
        FormulaExpr::Not(Box::new(expr))
    },
    "!" <expr:FormulaAtom> => {
        FormulaExpr::Not(Box::new(expr))
    },
    // Parentheses
    "(" <expr:FormulaExpr> ")" => {
        FormulaExpr::Paren(Box::new(expr))
    },
    // Modal operators (action-labeled)
    // <action> φ - diamond (possibility) with action label
    "<" <properties:PropertyList> ">" <expr:FormulaAtom> => {
        FormulaExpr::Diamond(properties, Box::new(expr))
    },
    // <> φ - unlabeled diamond (some transition exists)
    "<" ">" <expr:FormulaAtom> => {
        FormulaExpr::Diamond(vec![], Box::new(expr))
    },
    // [action] φ - box (necessity) with action label
    "[" <properties:PropertyList> "]" <expr:FormulaAtom> => {
        FormulaExpr::Box(properties, Box::new(expr))
    },
    // [] φ - unlabeled box (all transitions)
    "[" "]" <expr:FormulaAtom> => {
        FormulaExpr::Box(vec![], Box::new(expr))
    },
    // [<action>] φ - diamond-box (committed): can do AND cannot refuse
    // Semantically: [-action] false & <+action> φ
    "[" "<" <properties:PropertyList> ">" "]" <expr:FormulaAtom> => {
        FormulaExpr::DiamondBox(properties, Box::new(expr))
    },
    // Fixed point operators (modal mu-calculus)
    // lfp(X, φ) - least fixed point
    "lfp" "(" <var:Ident> "," <expr:FormulaExpr> ")" => {
        FormulaExpr::Lfp(var, Box::new(expr))
    },
    // gfp(X, φ) - greatest fixed point
    "gfp" "(" <var:Ident> "," <expr:FormulaExpr> ")" => {
        FormulaExpr::Gfp(var, Box::new(expr))
    },
    // μX.φ - alternate notation for lfp
    "μ" <var:Ident> "." <expr:FormulaAtom> => {
        FormulaExpr::Lfp(var, Box::new(expr))
    },
    // νX.φ - alternate notation for gfp
    "ν" <var:Ident> "." <expr:FormulaAtom> => {
        FormulaExpr::Gfp(var, Box::new(expr))
    },
    // Temporal operators (syntactic sugar for fixed points)
    // eventually(f) ≡ lfp(X, <>X | f)
    "eventually" "(" <expr:FormulaExpr> ")" => {
        FormulaExpr::Eventually(Box::new(expr))
    },
    // always(f) ≡ gfp(X, []X & f)
    "always" "(" <expr:FormulaExpr> ")" => {
        FormulaExpr::Always(Box::new(expr))
    },
    "next" "(" <expr:FormulaExpr> ")" => {
        FormulaExpr::Next(Box::new(expr))
    },
    // Unicode temporal operators
    "◇" "(" <expr:FormulaExpr> ")" => {
        FormulaExpr::Eventually(Box::new(expr))
    },
    "□" "(" <expr:FormulaExpr> ")" => {
        FormulaExpr::Always(Box::new(expr))
    }
};

Ident: String = {
    r#"[a-zA-Z_][a-zA-Z0-9_]*"# => <>.to_string()
};

// Contract parsing
pub ContractDecl: Contract = {
    "contract" <name:Ident> "{" <commits:CommitDecl*> "}" => {
        let mut contract = Contract::new(name);
        for commit in commits {
            contract.add_commit(commit);
        }
        contract
    }
};

CommitDecl: ContractCommit = {
    // commit { statements }
    "commit" "{" <stmts:CommitStatementList?> "}" => {
        let mut commit = ContractCommit::new(String::new(), String::new());
        if let Some(statements) = stmts {
            for stmt in statements {
                match &stmt {
                    CommitStatement::SignedBy { party, signature } => {
                        commit.signed_by = party.clone();
                        commit.signature = signature.clone();
                    }
                    CommitStatement::Model(model) => commit.model = Some(model.clone()),
                    CommitStatement::AddRule(_) | CommitStatement::Do(_) => commit.add_statement(stmt),
                }
            }
        }
        commit
    }
};

CommitStatementList: Vec<CommitStatement> = {
    <stmt:CommitStatement> => vec![stmt],
    <stmts:CommitStatementList> <stmt:CommitStatement> => {
        let mut list = stmts;
        list.push(stmt);
        list
    }
};

CommitStatement: CommitStatement = {
    // signed_by X "signature"
    "signed_by" <party:Ident> <sig:StringLiteral> => CommitStatement::SignedBy { party, signature: sig },
    
    // model { parts }
    "model" "{" <parts:Part*> "}" => {
        let mut model = Model::new("inline".to_string());
        for part in parts {
            model.add_part(part);
        }
        CommitStatement::Model(model)
    },
    
    // add_rule { formula } (adds rule, transitions as +ADD_RULE in model)
    "add_rule" "{" <expr:FormulaExpr> "}" => CommitStatement::AddRule(expr),
    
    // do +PROPERTY (domain action)
    "do" <props:PropertyList> => CommitStatement::Do(props)
};
