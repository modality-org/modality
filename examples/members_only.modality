// Members-Only Contract
//
// Only members can post to this contract.
// Adding a new member requires ALL current members to sign.
//
// State structure:
//   /members/
//     alice.id → "alice_pubkey_hex"
//     bob.id → "bob_pubkey_hex"
//
// When adding a RULE commit, you must also submit a MODEL that satisfies it.

model members_only {
  initial active
  
  // Simple self-loop - any commit is allowed structurally
  // Permissions are enforced by rules via predicates, not model structure
  active -> active []
}

// Rule 1: Any commit must be signed by at least one member
//
// The +any_signed predicate enumerates all .id files under /members/
// and checks if at least one has signed this commit.
rule member_required {
  formula {
    always (+any_signed(/members))
  }
}

// Rule 2: Modifying membership requires ALL current members to sign
//
// The +modifies predicate checks if the commit writes to paths under /members/.
// The interpretation of +all_signed(/members) evolves as members are added:
//   - When alice is the only member: all_signed = [alice]
//   - After bob is added: all_signed = [alice, bob]
//   - After carol is added: all_signed = [alice, bob, carol]
//
// The RULE never changes, but its INTERPRETATION does based on state.
rule membership_change_unanimous {
  formula {
    always (+modifies(/members) implies +all_signed(/members))
  }
}

// ============================================================
// EXAMPLE WORKFLOW (using modal CLI)
// ============================================================
//
// 1. Create contract and add first member (alice):
//    modal c create members_only
//    modal c commit --method post --path /members/alice.id \
//      --value "$(modal identity show alice --public-key-hex)" \
//      --sign alice.key
//
// 2. Add model:
//    modal c commit --method model \
//      --value "model members_only { initial active; active -> active [] }" \
//      --sign alice.key
//
// 3. Add rules (predicate-based, no action label references):
//    modal c commit --method rule \
//      --value "rule member_required { formula { always (+any_signed(/members)) } }" \
//      --sign alice.key
//
//    modal c commit --method rule \
//      --value "rule membership_unanimous { formula { always (+modifies(/members) implies +all_signed(/members)) } }" \
//      --sign alice.key
//
// 4. Alice adds Bob (only alice needs to sign - she's the only member):
//    modal c commit --method post --path /members/bob.id \
//      --value "$(modal identity show bob --public-key-hex)" \
//      --sign alice.key
//    ✓ Passes: +modifies(/members)=true, +all_signed([alice])=true
//
// 5. Now to add Carol, BOTH alice and bob must sign:
//    modal c commit --method post --path /members/carol.id \
//      --value "$(modal identity show carol --public-key-hex)" \
//      --sign alice.key --sign bob.key
//    ✓ Passes: +modifies(/members)=true, +all_signed([alice,bob])=true
//
// 6. Any member can post data (not modifying /members):
//    modal c commit --method post --path /data/notes.md \
//      --value "# Meeting notes..." \
//      --sign bob.key
//    ✓ Passes: +any_signed(/members)=true, +modifies(/members)=false
//
// 7. Non-members rejected:
//    modal c commit --method post --path /data/hack.md \
//      --value "Unauthorized!" \
//      --sign stranger.key
//    ✗ Rejected: +any_signed(/members)=false (stranger ∉ members)
